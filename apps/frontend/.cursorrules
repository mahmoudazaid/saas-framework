# Flutter Frontend Framework - Cursor AI Rules

> **ğŸš¨ CRITICAL: READ THIS FILE FIRST BEFORE ANY TASK**
> 
> This file contains ALL Flutter framework rules that MUST be followed.
> Failure to follow these rules will result in code that violates Flutter best practices.

**ALWAYS CHECK THIS FILE BEFORE:**
- Creating any new Flutter files
- Making architectural decisions
- Writing Flutter-specific code
- Adding new features or widgets

## âš¡ Quick Reference - Most Critical Rules

### ğŸš« NEVER DO (Will Break Flutter Framework)
- âŒ Use business-specific naming (use generic terms)
- âŒ Mix platform concerns in shared code
- âŒ Skip error handling in async operations
- âŒ Use deprecated Flutter APIs
- âŒ Skip widget testing
- âŒ Hardcode platform-specific code

### âœ… ALWAYS DO (Essential)
- âœ… Follow Flutter best practices
- âœ… Use generic, reusable terminology
- âœ… Implement proper error handling
- âœ… Write comprehensive tests
- âœ… Use proper state management
- âœ… Follow Material Design guidelines

## ğŸ—ï¸ Flutter Framework Architecture

This is a **generic Flutter framework** designed for:
- **Multi-platform**: Mobile (iOS/Android) + Web
- **Multi-tenant**: Support multiple tenants
- **Generic**: Reusable for any business domain
- **Clean Architecture**: Domain, Application, Infrastructure, Presentation layers

## ğŸ“ Directory Structure Rules

### Core Framework (`lib/core/`)
- **Entities**: `lib/core/entities/` - Domain entities
- **Constants**: `lib/core/constants/` - App constants
- **Config**: `lib/core/config/` - App configuration
- **Utils**: `lib/core/utils/` - Utility functions
- **Error**: `lib/core/error/` - Error handling
- **State**: `lib/core/state/` - State management
- **Cache**: `lib/core/cache/` - Caching strategies
- **Offline**: `lib/core/offline/` - Offline support

### Features (`lib/features/`)
- **Domain**: `lib/features/*/domain/` - Business logic
- **Data**: `lib/features/*/data/` - Data layer
- **Presentation**: `lib/features/*/presentation/` - UI layer

### UI Framework (`lib/ui/`)
- **Styles**: `lib/ui/styles/` - Design tokens
- **Widgets**: `lib/ui/widgets/` - Reusable widgets
- **Themes**: `lib/ui/themes/` - App themes

### Localization (`lib/l10n/`)
- **ARB Files**: `lib/l10n/arb/` - Localization files
- **Generated**: `lib/l10n/arb/` - Generated localization

## ğŸ¯ Generic Framework Rules

### Reusability
- Keep everything generic and reusable
- Use generic terminology (Entity, Tenant, User)
- Avoid business-specific naming
- Design for multiple domains (e-commerce, healthcare, education, etc.)

### Multi-tenancy
- All entities should support multi-tenancy
- Use `tenantId` for tenant context
- Use `tenantSlug` for tenant identification
- Generic tenant management

### Technology Stack
- **Frontend**: Flutter + Dart
- **State Management**: Riverpod
- **Navigation**: GoRouter
- **Localization**: Flutter Intl
- **Testing**: Flutter Test + Mocktail
- **Caching**: SharedPreferences + Memory
- **HTTP**: http package

## ğŸ“ File Naming Rules

### Flutter Files
- Use snake_case for files: `user_service.dart`
- Use PascalCase for classes: `UserService`
- Use camelCase for methods: `createUser()`
- Use kebab-case for directories: `user-management/`

### Test Files
- Use snake_case: `user_service_test.dart`
- Place in `test/` directory
- Mirror lib structure: `test/features/user/domain/`

## ğŸ”§ Development Workflow

### Flutter Development
1. Follow Clean Architecture layers
2. Use Riverpod for state management
3. Write tests for all new code
4. Use generic terminology
5. Validate all inputs with DTOs

### State Management
1. Use `StateNotifier` for complex state
2. Use `Provider` for simple state
3. Use `FutureProvider` for async data
4. Use `StreamProvider` for streams
5. Implement proper error handling

### UI Development
1. Follow Material Design guidelines
2. Use generic, reusable widgets
3. Support both mobile and web
4. Implement proper responsive design
5. Use consistent design tokens

## ğŸš¨ Critical Rules

### MUST DO:
1. âœ… Keep everything generic and reusable
2. âœ… Use multi-tenant architecture
3. âœ… Follow Flutter best practices
4. âœ… Write tests for all new code
5. âœ… Use consistent naming conventions
6. âœ… Document complex logic
7. âœ… Handle errors properly
8. âœ… Use proper logging
9. âœ… Follow security best practices
10. âœ… Monitor and optimize performance

### NEVER DO:
1. âŒ Use business-specific naming
2. âŒ Mix platform concerns
3. âŒ Skip testing
4. âŒ Hardcode configuration
5. âŒ Skip error handling
6. âŒ Use platform-specific code in shared areas
7. âŒ Skip documentation
8. âŒ Create circular dependencies
9. âŒ Commit secrets to version control
10. âŒ Ignore performance bottlenecks

## ğŸ§ª Testing Rules

### Test Organization
- **Unit Tests**: Test individual functions/classes
- **Widget Tests**: Test UI components
- **Integration Tests**: Test feature workflows
- **No E2E Tests**: Framework doesn't use E2E tests

### Test Tagging
- Use comprehensive test tags
- Tag by category: `unit`, `integration`, `widget`
- Tag by type: `smoke`, `regression`, `performance`
- Tag by priority: `critical`, `high`, `medium`, `low`
- Tag by scope: `core`, `feature`, `ui`, `api`

### Test Execution
```bash
# Run specific test types
flutter test --tags unit
flutter test --tags smoke
flutter test --tags "feature,fast"

# Exclude specific tests
flutter test --exclude-tags slow
flutter test --exclude-tags network
```

## ğŸ¨ UI/UX Rules

### Design System
- Use consistent design tokens
- Follow Material Design guidelines
- Support both light and dark themes
- Implement proper responsive design
- Use generic, reusable components

### Widget Development
- Create generic, reusable widgets
- Use proper widget composition
- Implement proper state management
- Handle loading and error states
- Support accessibility

### Navigation
- Use GoRouter for navigation
- Implement proper route guards
- Handle deep linking
- Support both mobile and web navigation

## ğŸ”’ Security Rules

### Data Protection
- Never hardcode sensitive data
- Use secure storage for sensitive information
- Implement proper input validation
- Sanitize user inputs
- Use HTTPS for all network requests

### Authentication
- Implement proper authentication flow
- Use secure token storage
- Handle token refresh
- Implement proper logout
- Support biometric authentication

### Authorization
- Implement proper authorization checks
- Use role-based access control
- Validate permissions on every action
- Handle unauthorized access gracefully

## ğŸš€ Performance Rules

### Flutter Performance
- Use `const` constructors where possible
- Implement proper widget rebuilding
- Use `ListView.builder` for large lists
- Optimize image loading and caching
- Implement proper memory management

### State Management Performance
- Use `Provider` for simple state
- Use `StateNotifier` for complex state
- Avoid unnecessary rebuilds
- Implement proper caching
- Use `Consumer` widgets efficiently

### Network Performance
- Implement proper caching
- Use pagination for large datasets
- Implement offline support
- Handle network errors gracefully
- Use proper loading states

## ğŸ“± Platform Support Rules

### Multi-Platform
- Support iOS, Android, and Web
- Use platform-agnostic code
- Handle platform-specific features
- Test on all target platforms
- Use responsive design

### Platform-Specific Code
- Use `Platform.isIOS`, `Platform.isAndroid`, `kIsWeb`
- Implement platform-specific UI when needed
- Handle platform-specific permissions
- Use platform-specific packages when necessary

## ğŸ”„ State Management Rules

### Riverpod Patterns
- Use `StateNotifier` for complex state
- Use `Provider` for simple state
- Use `FutureProvider` for async data
- Use `StreamProvider` for streams
- Implement proper error handling

### State Organization
- Keep state close to where it's used
- Use proper state composition
- Implement proper state persistence
- Handle state synchronization
- Use proper state validation

## ğŸ¯ Error Handling Rules

### Error Types
- Use `FrameworkException` for framework errors
- Use `ValidationException` for validation errors
- Use `NetworkException` for network errors
- Use `AuthenticationException` for auth errors
- Use `EntityNotFoundException` for missing entities

### Error Handling
- Implement proper error boundaries
- Show user-friendly error messages
- Log errors for debugging
- Handle errors gracefully
- Implement proper retry mechanisms

## ğŸ“Š Logging Rules

### Logging Levels
- Use appropriate log levels
- Log important events
- Log errors and exceptions
- Log performance metrics
- Log user actions

### Logging Implementation
- Use consistent logging format
- Include relevant context
- Avoid logging sensitive data
- Implement proper log rotation
- Use structured logging

## ğŸ”§ Development Tools Rules

### Code Quality
- Use `flutter analyze` regularly
- Fix all analysis issues
- Use proper code formatting
- Implement proper linting rules
- Use consistent code style

### Testing Tools
- Use `flutter test` for unit tests
- Use `flutter test --tags` for tagged tests
- Use `flutter test --coverage` for coverage
- Use `flutter test --reporter` for reporting
- Use `flutter test --concurrency` for parallel tests

### Build Tools
- Use `flutter build` for production builds
- Use `flutter build web` for web builds
- Use `flutter build apk` for Android builds
- Use `flutter build ios` for iOS builds
- Use proper build configurations

## ğŸ“š Documentation Rules

### File Structure Rules
- **ONLY ONE README.md** at project root level
- **NO multiple README files** in subdirectories
- **Use descriptive filenames** instead of numbered files
- **Link everything** from the main README.md

### File Naming
- **Use kebab-case** for file names (`clean-architecture.md`)
- **Use descriptive names** (`error-handling.md` not `handling-01.md`)
- **NO numbering** in documentation files
- **Group by topic/folder** rather than numbers

### Directory Organization
- **Shared docs** (`docs/`) for project-wide concepts
- **App-specific docs** (`apps/frontend/docs/`) for Flutter-specific implementation
- **Backend docs** (`apps/backend/docs/`) for backend-specific implementation
- **Cross-references** between shared and app docs
- **Single source of truth** (main README.md)

### Content Rules
- **Link between shared and app-specific docs**
- **Use relative paths** for internal links
- **Group links by category** (Architecture vs Development vs Testing)
- **Keep links updated** when moving files
- **Maintain cross-references** between all documentation levels

### Content Structure
- **Start with clear title and description**
- **Use consistent markdown formatting**
- **Include practical examples**
- **Cross-reference related documentation**
- **Use emojis for visual organization**

### Code Examples
- **Use Dart** for Flutter examples
- **Include both success and error cases**
- **Provide complete, runnable examples**
- **Use consistent code formatting**

### Documentation Standards
- **Update after adding new features**
- **Update when changing Flutter patterns**
- **Update after architectural changes**
- **Test all code examples**
- **Keep cross-references updated**
- **Update when moving or renaming files**
- **Verify all links work** after changes
- **Maintain consistent structure** across all docs

### Documentation Maintenance
- **Regular review** of documentation accuracy
- **Update examples** when code changes
- **Remove outdated** information
- **Add new sections** as framework evolves
- **Keep cross-references** synchronized

### Technology Rules
- **Markdown** as primary documentation format
- **Manual documentation** approach (no auto-generation)
- **Dart comments** in code for developer experience
- **Comprehensive coverage** of all framework aspects
- **Focus on Markdown docs** for comprehensive documentation

### Documentation Structure
```
Project Root
â”œâ”€â”€ README.md (ONLY README.md allowed)
â”œâ”€â”€ docs/ (Shared documentation)
â”‚   â”œâ”€â”€ architecture/
â”‚   â”œâ”€â”€ development/
â”‚   â””â”€â”€ api/
â””â”€â”€ apps/
    â”œâ”€â”€ backend/
    â”‚   â””â”€â”€ docs/
    â”‚       â”œâ”€â”€ backend-documentation-overview.md
    â”‚       â”œâ”€â”€ architecture/
    â”‚       â”œâ”€â”€ development/
    â”‚       â”œâ”€â”€ testing/
    â”‚       â””â”€â”€ api/
    â””â”€â”€ frontend/
        â””â”€â”€ docs/
            â”œâ”€â”€ frontend-documentation-overview.md
            â”œâ”€â”€ architecture/
            â”œâ”€â”€ development/
            â”œâ”€â”€ testing/
            â”œâ”€â”€ ui/
            â””â”€â”€ api/
```

### Naming Conventions
- **Use descriptive filenames** (`frontend-documentation-overview.md`)
- **NO numbering** in documentation files
- **Use kebab-case** for all documentation files
- **Group by topic/folder** rather than numbers
- **Avoid generic names** like "index" or "guide"

### Quality Checklist
- **All links work** and point to correct files
- **Code examples run** and are tested
- **Cross-references updated** when files move
- **Consistent formatting** across all docs
- **No broken references** to non-existent files
- **Single README.md** at project root only

### Flutter-Specific Documentation
- **Document Flutter patterns** and best practices
- **Include Riverpod state management** examples
- **Document GoRouter navigation** patterns
- **Include Material Design** implementation guides
- **Document testing strategies** for Flutter
- **Include performance optimization** techniques
- **Document multi-platform** considerations
- **Include localization** implementation guides

### Code Documentation
- **Document all public APIs** with Dart comments
- **Use proper Dart documentation** comments
- **Document complex Flutter logic**
- **Include usage examples** for widgets and services
- **Keep documentation updated** with code changes

### Architecture Documentation
- **Document Flutter architectural decisions**
- **Document Clean Architecture** implementation
- **Document state management** patterns
- **Document error handling** strategies
- **Document testing strategies** for Flutter

## ğŸš¨ Rule Enforcement

### Pre-Action Validation
- **ALWAYS read this file** before starting any Flutter task
- **Check rule applicability** before making changes
- **Verify file locations** match Flutter structure
- **Confirm naming conventions** before creating files

### During Development
- **Reference rules** when making decisions
- **Stop and check** if unsure about rule compliance
- **Ask for clarification** rather than assume
- **Follow the "answer before act"** pattern for complex changes

### Post-Action Verification
- **Verify no business-specific naming** violations
- **Check file naming** follows snake_case convention
- **Ensure proper testing** is implemented
- **Validate error handling** is comprehensive

### Rule Violation Prevention
- **NEVER use business-specific naming**
- **NEVER skip error handling**
- **NEVER skip testing**
- **NEVER hardcode configuration**
- **NEVER ignore Flutter best practices**
- **NEVER create multiple README.md files**
- **NEVER use numbered documentation files**
- **NEVER skip documentation updates**
- **NEVER ignore .cursorrules files**

### Documentation Rule Violation Actions
If documentation work violates rules:
1. **STOP immediately** and read this file
2. **Review the violation** against documentation-specific rules
3. **Refactor documentation** to follow naming conventions
4. **Use descriptive filenames** instead of numbered files
5. **Add proper cross-references** and links
6. **Update main README.md** with new documentation

### Documentation Work Enforcement
When working on documentation:
- [ ] **MUST read** this file FIRST
- [ ] **MUST follow** kebab-case naming convention
- [ ] **MUST use** descriptive filenames
- [ ] **MUST avoid** numbered files
- [ ] **MUST implement** proper cross-references
- [ ] **MUST add** links to main README.md
- [ ] **MUST maintain** consistent structure
- [ ] **MUST test** all code examples
- [ ] **MUST update** cross-references when moving files

## ğŸ¯ Flutter Framework Goals

1. **Generic Framework**: Reusable for any business domain
2. **Multi-tenant**: Support multiple tenants
3. **Multi-platform**: Support mobile and web
4. **Scalable**: Handle growth and complexity
5. **Maintainable**: Clean, documented, tested code
6. **Production-ready**: Robust, secure, performant
7. **Developer-friendly**: Easy to use and extend

## ğŸ”„ Adding New Rules

When adding new rules:
1. Determine if it's Flutter-specific or general
2. Add Flutter-specific rules to this file
3. Add general rules to root `.cursorrules`
4. Update relevant sections
5. Test with actual Flutter code examples
6. Keep rules generic and reusable

## ğŸš¨ Flutter-Specific Violations

If Flutter work violates rules:
1. **STOP immediately** and read this file
2. **Review the violation** against Flutter-specific rules
3. **Refactor code** to follow Flutter best practices
4. **Use generic terminology** instead of business-specific terms
5. **Add proper error handling** and state management
6. **Write comprehensive tests** for new functionality

## ğŸ“‹ Flutter Work Checklist

Before completing any Flutter task, verify:
- [ ] All Flutter-specific rules followed
- [ ] Generic framework principles maintained
- [ ] No business-specific naming violations
- [ ] File naming follows snake_case convention
- [ ] Proper testing implemented
- [ ] Error handling comprehensive
- [ ] State management follows Riverpod patterns
- [ ] UI follows Material Design guidelines
- [ ] Multi-platform support maintained
- [ ] Performance optimized
- [ ] Documentation follows naming conventions
- [ ] No README.md violations created
- [ ] Cross-references updated when needed
- [ ] Links verified and working